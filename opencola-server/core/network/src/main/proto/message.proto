syntax = "proto3";

package io.opencola.network.protobuf;

import "security.proto";
import "model.proto";

message MessageHeader {
  // Placeholder for future use
}

enum MessageType {
  EMPTY = 0;
  PING = 1;
  PONG = 2;
  GET_TRANSACTIONS = 3;
  PUT_TRANSACTION = 4;
  GET_DATA = 5;
  PUT_DATA = 6;
}

message UnsignedMessage {
  MessageHeader header = 1;
  MessageType type = 2;
  bytes payload = 3;
}

message SignedMessage {
  io.opencola.model.protobuf.Id from = 1;
  // The message needs to have a stable set of bytes to sign, so we use the serialized bytes here
  // instead of a typed UnsignedMessage
  bytes unsignedMessageBytes = 2;
  io.opencola.security.protobuf.Signature signature = 3;
}

message MessageEnvelope {
  io.opencola.model.protobuf.Id to = 1;
  // Network providers may implement their own end to end encryption (e.g. OCRelayNetworkProvider), in which case,
  // passing signed messages is safe. If not (e.g. HttpNetworkProvider), the message should be encrypted.
  oneof message {
    SignedMessage signedMessage = 2;
    io.opencola.security.protobuf.EncryptedBytes encryptedSignedMessage = 3;
  }
}

message GetTransactionsMessage {
  // Current transaction id from the peer requesting transactions
  io.opencola.model.protobuf.Id currentTransactionId = 1;
  int32 maxTransactions = 2;
}

message PutTransactionMessage {
  // Transactions are sent as bytes to preserve signatures
  bytes signedTransaction = 1;

  // The persona's current transaction id, used to determine whether more transactions should be
  // requested from the peer receiving the transaction
  io.opencola.model.protobuf.Id currentTransactionId = 2;
}

message GetDataMessage {
  io.opencola.model.protobuf.Id id = 1;
}

message PutDataMessage {
  io.opencola.model.protobuf.Id id = 1;
  bytes data = 2;
}

