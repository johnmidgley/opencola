syntax = "proto3";

package io.opencola.serialization.protobuf;

import "security.proto";

message Attribute {
  oneof value {
    uint32 ordinal = 1;
    string uri = 2;
  }
}

enum OCType {
    EMPTY = 0;
    BOOLEAN = 1;
    INT = 2;
    LONG = 3;
    FLOAT = 4;
    DOUBLE = 5;
    STRING = 6;
    BYTES = 7;
    DATETIME = 8;
    URI = 9;
    UUID = 10;
    ID = 11;
    PUBLIC_KEY = 12;
}

message Value {
  OCType ocType = 1;
  oneof value {
    double double = 3;
    float float = 4;
    int32 int32 = 5;
    int64 int64 = 6;
    uint32 uint32 = 7;
    uint64 uint64 = 8;
    sint32 sint32 = 9;
    sint64 sint64 = 10;
    fixed32 fixed32 = 11;
    fixed64 fixed64 = 12;
    sfixed32 sfixed32 = 13;
    sfixed64 sfixed64 = 14;
    bool bool = 15;
    string string = 16;
    bytes bytes = 17;
  }
}

enum Operation {
  RETRACT = 0;
  ADD = 1;
}

message TransactionFact {
  Attribute attribute = 1;
  Value value = 2;
  Operation operation = 3;
}

message Id {
  bytes bytes = 1;
}

message TransactionEntity {
  Id entityId = 1;
  repeated TransactionFact facts = 2;
}

message Transaction {
  Id id = 1;
  Id authorityId = 2;
  repeated TransactionEntity transactionEntities = 3;
  uint64 epochSecond = 4;
}

message SignedTransaction {
  /*
  From https://protobuf.dev/overview/:

  * When protocol buffers are serialized, the same data can have many different binary serializations.
  You cannot compare two messages for equality without fully parsing them.

  In order for a signature to validated, then, the exact bytes of the serialized transaction must be preserved, which
  is why we use a bytes type here, rather than a Transaction message.
   */
  bytes transaction = 1;
  Signature signature = 2;
}