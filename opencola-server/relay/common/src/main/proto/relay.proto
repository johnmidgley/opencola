syntax = "proto3";

package io.opencola.relay.common.protobuf;
import "security.proto";

message Identity {
  io.opencola.security.protobuf.PublicKey publicKey = 1;
}

message Challenge {
  io.opencola.security.protobuf.Signature.Algorithm algorithm = 1;
  bytes challenge = 2;
}

message ChallengeResponse {
  io.opencola.security.protobuf.Signature signature = 1;
}

enum AuthenticationStatus {
  AUTHENTICATED = 0;
  FAILED_CHALLENGE = 1;
}

message AuthenticationResult {
  AuthenticationStatus status = 1;
}

message Header {
  bytes messageId = 1;
  io.opencola.security.protobuf.PublicKey from = 2; // Public key of the sender
  io.opencola.security.protobuf.Signature signature = 3;
}

message Message {
  Header header = 1;
  bytes body = 2;
}

message Envelope {
  // Public key of the recipient, encrypted by the server's public key
  io.opencola.security.protobuf.EncryptedBytes to = 1;

  // Message key used for deduplication. When present, if the relay has to store the message, only one with the same
  // key will be stored. If not present, the message is considered transient and will not be stored.
  bytes key = 2;

  bytes message = 3;
}

message Control {
  enum Type {
    NO_PENDING_MESSAGES = 0;
  }

  Type type = 1;
  optional bytes payload = 2;
}



