syntax = "proto3";

package io.opencola.relay.common.protobuf;
import "security.proto";
import "util.proto";

message Identity {
  io.opencola.security.protobuf.PublicKey publicKey = 1;
}

message Challenge {
  io.opencola.security.protobuf.Signature.Algorithm algorithm = 1;
  bytes challenge = 2;
}

message ChallengeResponse {
  io.opencola.security.protobuf.Signature signature = 1;
}

enum AuthenticationStatus {
  NONE = 0;
  AUTHENTICATED = 1;
  FAILED_CHALLENGE = 2;
  NOT_AUTHORIZED = 3;
}

message AuthenticationResult {
  AuthenticationStatus status = 1;
}

message Recipient {
  io.opencola.security.protobuf.PublicKey to = 1;
  io.opencola.security.protobuf.EncryptedBytes messageSecretKey = 2; // Encrypted io.opencola.security.protobuf.SecretKey
}

// Signed and encrypted and then put in an Envelope
message Message {
  io.opencola.util.protobuf.UUID id = 1;
  io.opencola.security.protobuf.PublicKey from = 2;
  bytes body = 3;
}

message EnvelopeHeader {
    repeated Recipient recipients = 1;
    bytes storageKey = 2;
}

message Envelope {
  // Encrypted with recipients / server public key and then signed by sender (or intermediate trust node)
  io.opencola.security.protobuf.SignedBytes header = 1;

  // Encrypted with per message AES key. Contains SignedBytes that proto decodes to Message and then signed by sender
  io.opencola.security.protobuf.SignedBytes message = 2;
}

message ControlMessage {
  enum Type {
    NONE = 0;

    // Sent by server after connection to inform client that all queued messages have been sent
    NO_PENDING_MESSAGES = 1;

    // Used by client and server to send admin messages
    ADMIN = 2;
  }

  Type type = 1;
  optional bytes payload = 2;
}



